// This file is part of conscheme
// Automatically generated by compiler/primitives.scm
package conscheme
import "fmt"
import "os"
func evprim(primop string, code Obj, lexenv map[string]Obj) Obj {
	switch primop {
	case "write/1":
		arg0 := ev(car(code), false, lexenv)
		return Write(arg0)
	case "display/1":
		arg0 := ev(car(code), false, lexenv)
		return Display(arg0)
	case "$cell-set!/2":
		v := ev(car(code), false, lexenv)
		vv := (*v).(*[1]Obj)
		vv[0] = ev(car(cdr(code)), false, lexenv)
		return Void
	case "$cell-ref/1":
		v := ev(car(code), false, lexenv)
		vv := (*v).(*[1]Obj)
		return vv[0]
	case "$make-cell/1":
		var v [1]Obj
		v[0] = ev(car(code), false, lexenv)
		var vv interface{} = &v
		return Obj(&vv)
	case "command-line/0":
		return Command_line()
	case "exit/1":
		os.Exit(number_to_int(ev(car(code), false, lexenv)))
	case "eq?/2":
		if ev(car(code), false, lexenv) == ev(car(cdr(code)), false, lexenv) {
			return True
		} else {
			return False
		}
	case "eof-object/0":
		return Eof
	case "unspecified/0":
		return Void
	case "make-string/2":
		arg0 := ev(car(code), false, lexenv);code = cdr(code)
		arg1 := ev(car(code), false, lexenv)
		return Make_string(arg0, arg1)
	case "make-string/1":
		return Make_string(ev(car(code), false, lexenv),Make_char(32))
	case "string-ref/2":
		arg0 := ev(car(code), false, lexenv);code = cdr(code)
		arg1 := ev(car(code), false, lexenv)
		return String_ref(arg0, arg1)
	case "string-length/1":
		arg0 := ev(car(code), false, lexenv)
		return String_length(arg0)
	case "string?/1":
		arg0 := ev(car(code), false, lexenv)
		return string_p(arg0)
	case "greatest-fixnum/0":
		return Make_fixnum(fixnum_max)
	case "least-fixnum/0":
		return Make_fixnum(fixnum_min)
	case "$-/2":
		arg0 := ev(car(code), false, lexenv);code = cdr(code)
		arg1 := ev(car(code), false, lexenv)
		return number_subtract(arg0, arg1)
	case "$//2":
		arg0 := ev(car(code), false, lexenv);code = cdr(code)
		arg1 := ev(car(code), false, lexenv)
		return number_divide(arg0, arg1)
	case "$+/2":
		arg0 := ev(car(code), false, lexenv);code = cdr(code)
		arg1 := ev(car(code), false, lexenv)
		return number_add(arg0, arg1)
	case "$number->string/2":
		arg0 := ev(car(code), false, lexenv);code = cdr(code)
		arg1 := ev(car(code), false, lexenv)
		return _number_to_string(arg0, arg1)
	case "=/2":
		arg0 := ev(car(code), false, lexenv);code = cdr(code)
		arg1 := ev(car(code), false, lexenv)
		return number_equal(arg0, arg1)
	case "number?/1":
		arg0 := ev(car(code), false, lexenv)
		return number_p(arg0)
	case "vector?/1":
		arg0 := ev(car(code), false, lexenv)
		return vector_p(arg0)
	case "char->integer/1":
		arg0 := ev(car(code), false, lexenv)
		return char_to_integer(arg0)
	case "char?/1":
		arg0 := ev(car(code), false, lexenv)
		return char_p(arg0)
	case "symbol?/1":
		arg0 := ev(car(code), false, lexenv)
		return symbol_p(arg0)
	case "set-cdr!/2":
		arg0 := ev(car(code), false, lexenv);code = cdr(code)
		arg1 := ev(car(code), false, lexenv)
		return set_cdr_ex(arg0, arg1)
	case "set-car!/2":
		arg0 := ev(car(code), false, lexenv);code = cdr(code)
		arg1 := ev(car(code), false, lexenv)
		return set_car_ex(arg0, arg1)
	case "length/1":
		arg0 := ev(car(code), false, lexenv)
		return Length(arg0)
	case "cdr/1":
		arg0 := ev(car(code), false, lexenv)
		return cdr(arg0)
	case "car/1":
		arg0 := ev(car(code), false, lexenv)
		return car(arg0)
	case "cons/2":
		arg0 := ev(car(code), false, lexenv);code = cdr(code)
		arg1 := ev(car(code), false, lexenv)
		return Cons(arg0, arg1)
	case "pair?/1":
		arg0 := ev(car(code), false, lexenv)
		return pair_p(arg0)
	case "not/1":
		arg0 := ev(car(code), false, lexenv)
		return not(arg0)
	case "boolean?/1":
		arg0 := ev(car(code), false, lexenv)
		return boolean_p(arg0)
	default:
		fmt.Fprintf(os.Stderr, "Please regenerate primitives.go\n")
		panic(fmt.Sprintf("Unimplemented primitive: %s",primop))
	}
	panic(fmt.Sprintf("Fell off the edge in evprim(): %s",primop))
}
